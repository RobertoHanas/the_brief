import os
import subprocess
import requests
from datetime import datetime
from pathlib import Path
from rich import print
from typing import Optional, Dict, Any
import json


class PublisherAgent:
    """
    Handles storing research briefs locally and optionally pushing to GitHub.

    Key features:
        - Local storage in organized folders
        - Optional GitHub publishing
        - Metadata tracking (JSON)
        - Multiple output formats (Markdown, JSON, HTML)
        - User-aware organization
        - Retry-safe logic
    """

    def __init__(self, repo_path="history", github_repo=None, github_token=None):
        self.github_repo = github_repo
        self.github_token = github_token
        
        # Automatically discover username or fall back to local_user
        self.user_id = self._resolve_github_user()
        
        # User-specific history folder
        self.repo_path = Path(repo_path) / self.user_id
        self.repo_path.mkdir(parents=True, exist_ok=True)
        
        # Metadata folder
        self.metadata_path = self.repo_path / "metadata"
        self.metadata_path.mkdir(exist_ok=True)

    # ---------------------------------------------------------
    #  USER ID RESOLUTION
    # ---------------------------------------------------------
    def _resolve_github_user(self) -> str:
        """Resolve GitHub username or return local_user."""
        if not self.github_token:
            print("[Publisher] No GitHub token â†’ using local_user.")
            return "local_user"

        try:
            resp = requests.get(
                "https://api.github.com/user",
                headers={"Authorization": f"token {self.github_token}"},
                timeout=5
            )
            if resp.status_code == 200:
                username = resp.json().get("login", "local_user")
                print(f"[Publisher] âœ“ Authenticated as: {username}")
                return username
        except Exception as e:
            print(f"[Publisher] âš ï¸  GitHub auth failed: {e}")

        print("[Publisher] Using local_user.")
        return "local_user"

    # ---------------------------------------------------------
    #  FILENAME GENERATION
    # ---------------------------------------------------------
    def _format_filename(self, topic: str, persona: str, ext: str = "md") -> str:
        """Generate a safe filename from topic and persona."""
        safe_topic = "".join(c if c.isalnum() or c in ('-', '_') else '_' for c in topic)[:50]
        safe_persona = "".join(c if c.isalnum() or c in ('-', '_') else '_' for c in persona)[:20]
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{safe_topic}_{safe_persona}_{ts}.{ext}"

    # ---------------------------------------------------------
    #  SAVE FUNCTIONS
    # ---------------------------------------------------------
    def _save_markdown(self, filename: str, topic: str, brief: str, 
                      persona: str, metadata: Dict[str, Any]) -> Optional[Path]:
        """Save brief as Markdown file."""
        filepath = self.repo_path / filename
        
        try:
            # Calculate acceptance rate
            total_items = metadata.get('total_items_collected', 0)
            relevant_items = metadata.get('relevant_items_count', 0)
            acceptance_rate = (relevant_items / total_items * 100) if total_items > 0 else 0
            
            # Get source stats
            sources = metadata.get('sources_discovered', {})
            
            content = f"""# {topic}

> **Research Brief** â€¢ Generated {datetime.now().strftime("%B %d, %Y at %I:%M %p")}

---

## ðŸ“‹ Research Overview

| Metric | Value |
|--------|-------|
| **Persona** | {persona} |
| **Items Analyzed** | {total_items} |
| **Relevant Items** | {relevant_items} ({acceptance_rate:.1f}% acceptance rate) |
| **RSS Feeds** | {sources.get('rss_feeds', 0)} |
| **Twitter Sources** | {sources.get('twitter_accounts', 0)} |
| **Websites Explored** | {sources.get('websites_explored', 0)} |
| **Subreddits** | {sources.get('subreddits', 0)} |

---

{brief}

---

## ðŸ” Research Metadata

**Topic Expansion:**
{self._format_topic_expansion(metadata.get('topic_expansion', {}))}

**Generated by:** Personal Research Butler  
**Timestamp:** {datetime.now().isoformat()}

---

*This brief was created by analyzing {total_items} sources and extracting the {relevant_items} most relevant items for your interests.*
"""
            
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(content)
            
            print(f"[Publisher] âœ“ Markdown saved â†’ {filepath}")
            return filepath
            
        except Exception as e:
            print(f"[Publisher] âœ— Error saving markdown: {e}")
            return None

    def _format_topic_expansion(self, expansion: Dict[str, Any]) -> str:
        """Format topic expansion data nicely."""
        if not expansion:
            return "*No expansion data available*"
        
        lines = []
        
        if 'original' in expansion:
            lines.append(f"- **Original Topic:** {expansion['original']}")
        
        if 'subtopics' in expansion and expansion['subtopics']:
            subtopics = expansion['subtopics'][:5]  # Limit to 5
            lines.append(f"- **Subtopics Explored:** {', '.join(subtopics)}")
        
        if 'keywords' in expansion and expansion['keywords']:
            keywords = expansion['keywords'][:8]  # Limit to 8
            lines.append(f"- **Keywords Used:** {', '.join(keywords)}")
        
        return '\n'.join(lines) if lines else "*No expansion data*"

    def _save_json(self, filename: str, topic: str, brief: str,
                   persona: str, metadata: Dict[str, Any]) -> Optional[Path]:
        """Save brief as JSON file with full metadata."""
        filepath = self.repo_path / filename
        
        try:
            data = {
                "topic": topic,
                "persona": persona,
                "timestamp": datetime.now().isoformat(),
                "brief": brief,
                "metadata": {
                    "total_items": metadata.get('total_items_collected', 0),
                    "relevant_items": metadata.get('relevant_items_count', 0),
                    "sources": metadata.get('sources_discovered', {}),
                    "topic_expansion": metadata.get('topic_expansion', {})
                }
            }
            
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            print(f"[Publisher] âœ“ JSON saved â†’ {filepath}")
            return filepath
            
        except Exception as e:
            print(f"[Publisher] âœ— Error saving JSON: {e}")
            return None

    def _save_html(self, filename: str, topic: str, brief: str,
                   persona: str, metadata: Dict[str, Any]) -> Optional[Path]:
        """Save brief as HTML file with nice styling."""
        filepath = self.repo_path / filename
        
        try:
            # Convert markdown to simple HTML (basic implementation)
            html_brief = brief.replace('\n\n', '</p><p>').replace('\n', '<br>')
            
            html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{topic}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }}
        h1 {{ color: #2c3e50; }}
        .meta {{
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }}
        .meta p {{ margin: 5px 0; }}
        .content {{ margin-top: 30px; }}
        footer {{
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #666;
            font-size: 0.9em;
        }}
    </style>
</head>
<body>
    <h1>{topic}</h1>
    <div class="meta">
        <p><strong>Persona:</strong> {persona}</p>
        <p><strong>Generated:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
        <p><strong>Items Analyzed:</strong> {metadata.get('total_items_collected', 0)}</p>
        <p><strong>Relevant Items:</strong> {metadata.get('relevant_items_count', 0)}</p>
    </div>
    <div class="content">
        <p>{html_brief}</p>
    </div>
    <footer>
        Generated by Personal Research Butler
    </footer>
</body>
</html>"""
            
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(html_content)
            
            print(f"[Publisher] âœ“ HTML saved â†’ {filepath}")
            return filepath
            
        except Exception as e:
            print(f"[Publisher] âœ— Error saving HTML: {e}")
            return None

    def _save_metadata(self, base_filename: str, metadata: Dict[str, Any]):
        """Save metadata as separate JSON file."""
        meta_filename = base_filename.replace('.md', '_meta.json')
        filepath = self.metadata_path / meta_filename
        
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)
            
            print(f"[Publisher] âœ“ Metadata saved â†’ {filepath}")
        except Exception as e:
            print(f"[Publisher] âœ— Error saving metadata: {e}")

    # ---------------------------------------------------------
    #  GITHUB PUSH (Optional)
    # ---------------------------------------------------------
    def _push_to_github(self, filepath: Path, filename: str) -> bool:
        """Push file to GitHub repository."""
        if not self.github_repo or not self.github_token:
            print("[Publisher] âš ï¸  GitHub not configured â†’ skipping push")
            return False

        print("[Publisher] ðŸš€ Pushing to GitHubâ€¦")

        try:
            # Configure git
            subprocess.run(
                ["git", "config", "--global", "user.email", "butler@research.ai"],
                check=True, capture_output=True
            )
            subprocess.run(
                ["git", "config", "--global", "user.name", "ResearchButler"],
                check=True, capture_output=True
            )

            repo_clone_path = Path("repo_clone")
            
            # Clone if needed
            if not repo_clone_path.exists():
                clone_url = f"https://{self.github_token}@github.com/{self.github_repo}.git"
                subprocess.run(
                    ["git", "clone", clone_url, str(repo_clone_path)],
                    check=True, capture_output=True
                )
                print("[Publisher] âœ“ Repository cloned")
            else:
                # Pull latest changes
                subprocess.run(
                    ["git", "-C", str(repo_clone_path), "pull"],
                    check=True, capture_output=True
                )

            # Create user folder
            user_folder = repo_clone_path / "projects" / self.user_id
            user_folder.mkdir(parents=True, exist_ok=True)

            # Copy file
            import shutil
            dest_file = user_folder / filename
            shutil.copy2(filepath, dest_file)

            # Commit and push
            subprocess.run(
                ["git", "-C", str(repo_clone_path), "add", f"projects/{self.user_id}/{filename}"],
                check=True, capture_output=True
            )
            subprocess.run(
                ["git", "-C", str(repo_clone_path), "commit", "-m", f"Add: {filename}"],
                check=True, capture_output=True
            )
            subprocess.run(
                ["git", "-C", str(repo_clone_path), "push"],
                check=True, capture_output=True
            )
            
            print(f"[Publisher] âœ“ Pushed to GitHub: {self.github_repo}")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"[Publisher] âœ— Git error: {e}")
            return False
        except Exception as e:
            print(f"[Publisher] âœ— GitHub push failed: {e}")
            return False

    # ---------------------------------------------------------
    #  MAIN RUN METHOD
    # ---------------------------------------------------------
    def run(self, topic: str, brief: str, persona: str, 
            metadata: Optional[Dict[str, Any]] = None,
            formats: list = None) -> str:
        """
        Main entry point - saves brief in multiple formats.
        
        Args:
            topic: Research topic
            brief: The generated brief content
            persona: User persona
            metadata: Additional metadata from pipeline
            formats: List of formats to save ['md', 'json', 'html']
        
        Returns:
            Path to the main markdown file
        """
        print(f"[Publisher] ðŸ’¾ Publishing brief for '{topic}'â€¦")
        
        if formats is None:
            formats = ['md']  # Default to markdown only
        
        metadata = metadata or {}
        
        # Generate base filename
        base_filename = self._format_filename(topic, persona)
        main_filepath = None
        
        # Save in requested formats
        if 'md' in formats:
            main_filepath = self._save_markdown(base_filename, topic, brief, persona, metadata)
        
        if 'json' in formats:
            json_filename = base_filename.replace('.md', '.json')
            self._save_json(json_filename, topic, brief, persona, metadata)
        
        if 'html' in formats:
            html_filename = base_filename.replace('.md', '.html')
            self._save_html(html_filename, topic, brief, persona, metadata)
        
        # Always save metadata separately
        self._save_metadata(base_filename, metadata)
        
        # Optionally push to GitHub (only markdown)
        if main_filepath and self.github_repo:
            self._push_to_github(main_filepath, base_filename)
        
        result_path = str(main_filepath) if main_filepath else ""
        print(f"[Publisher] âœ… Publishing complete: {result_path}")
        
        return result_path